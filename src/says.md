# says

[exact?](./exact_question.md) や [apply?](./apply_question.md) は証明を書いている過程で使用することを想定したタクティクです．`Try this: ` という提案をクリックして採用したら，`exact?` や `apply?` は提案内容で上書きされて，最終的な証明には残りません．

では，証明のある部分が `apply?` などにより提案された内容であることを明示したい場合はどうしたら良いでしょうか？`says` タクティクはまさにその問題を解決するタクティクです．提案タクティクを残しつつ，実際には実行されないようにします．

[simp](./simp.md) や [aesop](./aesop.md) のような証明自動化系のタクティクに対して，動作を軽量化しながらも証明の読みやすさを保つという目的でも使用できます．たとえば `aesop? says ...` と書かれていたら，その後のブロックでどんな複雑なことが書かれていようと，単に `aesop` の発見した証明内容を丁寧に書いているだけだとわかるわけです．

```lean
{{#include ../Examples/Says.lean}}
```

## オプション

* `says.verify : Bool` : `true` にすると，`X says Y` の `Y` のところに，実際には提案されていないタクティクを入れたときにエラーになります．

* `says.no_verify_in_CI : Bool` : `true` にすると，CI 環境で `X says Y` の `Y` の部分が実際に提案されている内容と一致するかのチェックが走らなくなります．
